<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>flp's website - projects</title><link href="https://pnahratow.github.io/" rel="alternate"></link><link href="https://pnahratow.github.io/feeds/projects.atom.xml" rel="self"></link><id>https://pnahratow.github.io/</id><updated>2024-05-06T00:00:00+02:00</updated><subtitle>I like big pixels and I cannot lie</subtitle><entry><title>Librequake Shambler Texture Painting Workflow</title><link href="https://pnahratow.github.io/lqshambler-paint-workflow.html" rel="alternate"></link><published>2024-05-06T00:00:00+02:00</published><updated>2024-05-06T00:00:00+02:00</updated><author><name>Philipp Nahratow</name></author><id>tag:pnahratow.github.io,2024-05-06:/lqshambler-paint-workflow.html</id><summary type="html">&lt;h2 id="update-2024-09-06"&gt;Update (2024-09-06)&lt;/h2&gt;
&lt;p&gt;I was very unhappy with the texture result and restarted the whole process without recording myself and paying attention that the colors
are pleasing. The first one was way too dark and dirty and I am happier with this second attempt.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://pnahratow.github.io/static/lqshambler/04_retex_front.png" style="max-height:500px" /&gt;
&lt;img src="https://pnahratow.github.io/static/lqshambler/05_retex_back.png" style="max-height:500px" /&gt;
&lt;img src="https://pnahratow.github.io/static/lqshambler/06_retex_flat.png" style="max-height:500px" /&gt;&lt;/p&gt;
&lt;h2 id="original-post-2024-05-06"&gt;Original Post (2024-05-06)&lt;/h2&gt;
&lt;p&gt;Once again I have …&lt;/p&gt;</summary><content type="html">&lt;h2 id="update-2024-09-06"&gt;Update (2024-09-06)&lt;/h2&gt;
&lt;p&gt;I was very unhappy with the texture result and restarted the whole process without recording myself and paying attention that the colors
are pleasing. The first one was way too dark and dirty and I am happier with this second attempt.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://pnahratow.github.io/static/lqshambler/04_retex_front.png" style="max-height:500px" /&gt;
&lt;img src="https://pnahratow.github.io/static/lqshambler/05_retex_back.png" style="max-height:500px" /&gt;
&lt;img src="https://pnahratow.github.io/static/lqshambler/06_retex_flat.png" style="max-height:500px" /&gt;&lt;/p&gt;
&lt;h2 id="original-post-2024-05-06"&gt;Original Post (2024-05-06)&lt;/h2&gt;
&lt;p&gt;Once again I have recorded myself painting.&lt;/p&gt;
&lt;div style="position: relative; width: 100%; height: 0; padding-bottom: 56.25%;"&gt;
    &lt;iframe src="https://www.youtube.com/embed/FU66AWL2gD8" frameborder="0" allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Since I switchted from painting in Krita 2D only to using Blender I thought maybe that would be a cool idea.&lt;/p&gt;
&lt;p&gt;It started with fixing seams in blender, where I would go over problematic seams with the smudge tool in blender and I always hesitated
to just fully do it in Blender because the toolset seems so shit.&lt;/p&gt;
&lt;p&gt;There are no layers, no filters, no everything. Its super bare bones.&lt;/p&gt;
&lt;p&gt;Let me tell you, it turns out I don't even need all these tools.
The toolset in blender is not zero. There are blending modes, smudge and blur. You can easliy mask of where you want to paint an where not. There is mirroring.
There is a color picker and swatcher, a lot of undo steps and thats pretty much enough.&lt;/p&gt;
&lt;p&gt;I used krita on two occasions. When I want to work with the palette conversion in realtime and when I need to copy paste 2d sections for some reasons.&lt;/p&gt;
&lt;p&gt;The highend route to take is Substance Painter with &lt;a href="https://actiondawg.itch.io/pixel8r2"&gt;Pixel8r&lt;/a&gt; and if you have the money just use that.
For all the other poor bastards blender does it just well enough.&lt;/p&gt;
&lt;h2 id="the-texture"&gt;The texture&lt;/h2&gt;
&lt;p&gt;This texure is for the Librequake shambler replacement which is based of this concept and the main inspiration for the texturing&lt;/p&gt;
&lt;p&gt;&lt;img src="https://pnahratow.github.io/static/lqshambler/00_concept.png" style="max-height:500px" /&gt;&lt;/p&gt;
&lt;p&gt;Here are the results&lt;/p&gt;
&lt;p&gt;&lt;img src="https://pnahratow.github.io/static/lqshambler/01_hollow_tex_front.png" style="max-height:500px" /&gt;
&lt;img src="https://pnahratow.github.io/static/lqshambler/02_hollow_tex_back.png" style="max-height:500px" /&gt;
&lt;img src="https://pnahratow.github.io/static/lqshambler/03_hollow_texture.png" style="max-height:500px" /&gt;&lt;/p&gt;
&lt;p&gt;I have to say that recording myself kind of sucked the fun out of texturing. I am also not really happy with the results and will attribute that by at least 50% to the fact that I was recording. I can't help but feel rushed. The realtime work in the video is 2.5h which seems very little.&lt;/p&gt;</content><category term="projects"></category><category term="gaming"></category></entry><entry><title>Chainforcer (Baseogre) Release</title><link href="https://pnahratow.github.io/chainforcer-baseogre-release.html" rel="alternate"></link><published>2024-02-09T00:00:00+01:00</published><updated>2024-02-09T00:00:00+01:00</updated><author><name>Philipp Nahratow</name></author><id>tag:pnahratow.github.io,2024-02-09:/chainforcer-baseogre-release.html</id><summary type="html">&lt;p&gt;&lt;em&gt;Hey, I finished the project and it only took about 400 weeks.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://pnahratow.github.io/static/baseogre_release/cut.png" style="max-height:500px" /&gt;&lt;/p&gt;
&lt;h2 id="files"&gt;Files&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://pnahratow.github.io/static/baseogre_release/baseogre.zip"&gt;Baseogre Quake MDL files - baseogre.zip&lt;/a&gt; - &lt;em&gt;Includes baseogre.mdl and h_baseogre.mdl&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://pnahratow.github.io/static/baseogre_release/baseogre_sources.zip"&gt;Baseogre Source Files - baseogre_sources.zip&lt;/a&gt; - &lt;em&gt;Includes the rigged and animated blender file and the texture as a .psd file including layers&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="description"&gt;Description&lt;/h2&gt;
&lt;p&gt;This finalizes the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;Hey, I finished the project and it only took about 400 weeks.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://pnahratow.github.io/static/baseogre_release/cut.png" style="max-height:500px" /&gt;&lt;/p&gt;
&lt;h2 id="files"&gt;Files&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://pnahratow.github.io/static/baseogre_release/baseogre.zip"&gt;Baseogre Quake MDL files - baseogre.zip&lt;/a&gt; - &lt;em&gt;Includes baseogre.mdl and h_baseogre.mdl&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://pnahratow.github.io/static/baseogre_release/baseogre_sources.zip"&gt;Baseogre Source Files - baseogre_sources.zip&lt;/a&gt; - &lt;em&gt;Includes the rigged and animated blender file and the texture as a .psd file including layers&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="description"&gt;Description&lt;/h2&gt;
&lt;p&gt;This finalizes the work shown in my earlier posts &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://pnahratow.github.io/chainforcer-lowpoly-modeling-stages.html"&gt;Chainforcer Lowpoly Modeling Stages&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="https://pnahratow.github.io/chainforcer-texture-paint-workflow.html"&gt;Chainforcer Texture Painting Workflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What can I say. Apparently I got so annoyed from painting this texture that I needed a seven year break to regenerate all the cells in my body or something.&lt;/p&gt;
&lt;p&gt;Nevertheless, it is done. Here is an ingame demo of the guy.&lt;/p&gt;
&lt;div style="position: relative; width: 100%; height: 0; padding-bottom: 56.25%;"&gt;
    &lt;iframe src="https://www.youtube.com/embed/UVERBoYa40g" frameborder="0" allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;The animations are setup so that they can directly replace the original Ogre model. Maybe to use the ogre enemy in base maps with a more fitting look. To do this just download the .mdl files and rename them to &lt;code&gt;ogre.mdl&lt;/code&gt; and &lt;code&gt;h_ogre.mdl&lt;/code&gt; and put the in the progs directory of your mod and you are good to go.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://pnahratow.github.io/static/baseogre_release/front.png" style="max-height:500px" /&gt;
&lt;img src="https://pnahratow.github.io/static/baseogre_release/back.png" style="max-height:500px" /&gt;&lt;/p&gt;
&lt;p&gt;If you are interested in technical details or just generally want to play with the source files. I have provided them at the top. In there you have the final state of the blender file after I was done with the process. The character is rigged and animated. &lt;/p&gt;
&lt;video controls playsinline autoplay muted loop preload="auto" style="width: 100%; max-width: 400px; height: auto;"&gt;
  &lt;source src="https://pnahratow.github.io/static/baseogre_release/rigged.webm" type="video/webm" /&gt;
&lt;/video&gt;

&lt;p&gt;The texture is included as well as a source file with layers. It is a mess so don't expect anything.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Skin original size" src="https://pnahratow.github.io/static/baseogre_release/skin512.png"&gt;&lt;/p&gt;
&lt;p&gt;After resize and color conversion to the quake palette the texture looks like this.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Skin converted for quake" src="https://pnahratow.github.io/static/baseogre_release/skin256_paletted_bayer_16.png"&gt;&lt;/p&gt;
&lt;p&gt;Nothing more to say. Have fun!&lt;/p&gt;
&lt;p&gt;&lt;img src="https://pnahratow.github.io/static/baseogre_release/leatherface.png"  style="max-height:600px" /&gt;
&lt;img src="https://pnahratow.github.io/static/baseogre_release/muzzleflash.png" style="max-height:500px" /&gt;&lt;/p&gt;</content><category term="projects"></category><category term="gaming"></category></entry><entry><title>Chainforcer Texture Painting Workflow</title><link href="https://pnahratow.github.io/chainforcer-texture-paint-workflow.html" rel="alternate"></link><published>2016-03-12T00:00:00+01:00</published><updated>2016-03-12T00:00:00+01:00</updated><author><name>Philipp Nahratow</name></author><id>tag:pnahratow.github.io,2016-03-12:/chainforcer-texture-paint-workflow.html</id><content type="html">&lt;div style="position: relative; width: 100%; height: 0; padding-bottom: 56.25%;"&gt;
    &lt;iframe src="https://www.youtube.com/embed/SlOZWpu9t7o" frameborder="0" allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;This is a timelapse video of me starting to texture my chainforcer model. I used blender and krita.&lt;/p&gt;</content><category term="projects"></category><category term="gaming"></category></entry><entry><title>Chainforcer Lowpoly Modeling Stages</title><link href="https://pnahratow.github.io/chainforcer-lowpoly-modeling-stages.html" rel="alternate"></link><published>2016-03-11T00:00:00+01:00</published><updated>2016-03-11T00:00:00+01:00</updated><author><name>Philipp Nahratow</name></author><id>tag:pnahratow.github.io,2016-03-11:/chainforcer-lowpoly-modeling-stages.html</id><summary type="html">&lt;p&gt;&lt;img alt="Chainforcer model" src="https://pnahratow.github.io/static/modprog/title_pose.png"&gt;&lt;/p&gt;
&lt;p&gt;While working on this model I saved several in between backups. These screenshots show the stages the model went through.&lt;/p&gt;
&lt;h2 id="concept-viewport-background"&gt;Concept / Viewport Background&lt;/h2&gt;
&lt;p&gt;The basic character concept and also essential viewport backgrounds that will define the form. Both views contain different information on one axis but the same on the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Chainforcer model" src="https://pnahratow.github.io/static/modprog/title_pose.png"&gt;&lt;/p&gt;
&lt;p&gt;While working on this model I saved several in between backups. These screenshots show the stages the model went through.&lt;/p&gt;
&lt;h2 id="concept-viewport-background"&gt;Concept / Viewport Background&lt;/h2&gt;
&lt;p&gt;The basic character concept and also essential viewport backgrounds that will define the form. Both views contain different information on one axis but the same on the vertical axis. To use this as viewport backgrounds I made sure the landmarks on the vertical axis are on the same height. That's why there are these lines.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Chainforcer model" src="https://pnahratow.github.io/static/modprog/00_background.png"&gt;&lt;/p&gt;
&lt;h2 id="blenders-skin-modifier"&gt;Blender's Skin Modifier&lt;/h2&gt;
&lt;p&gt;The basic form is created using a combination of blender modifiers (mirror, skin, subdivison). You can see a thin line inside the model. Thats what's manually defined. The actual hull is what the skinmodifier does. It creates a hull mesh around verts and edges. Geometry will be added when verts move apart. The volume increases when verts are scaled. The geometry isn't optimal but I think it still saves time since I only had to define 13 vertices to get this basic shape.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Skin modifier" src="https://pnahratow.github.io/static/modprog/01_skinmod.png"&gt;
&lt;img alt="Skin modifier with arms" src="https://pnahratow.github.io/static/modprog/02_skinmod_w_arms.png"&gt;&lt;/p&gt;
&lt;h2 id="refining"&gt;Refining&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Started with the boots by moving the verts from all angles so they align with the background images.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Boot progress" src="https://pnahratow.github.io/static/modprog/03_progress_boot.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Removed some unneccessary edges to have about even poly density.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Less geometry" src="https://pnahratow.github.io/static/modprog/04_less_geometry.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I noticed some triangles in the geometry and removed them by adding edge loops.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Better topology" src="https://pnahratow.github.io/static/modprog/05_better_topo.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gradually touching all vertices to define the form.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Defining general shape" src="https://pnahratow.github.io/static/modprog/06_getting_in_shape.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Some more form definiton on the hips and head.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Hip and head details" src="https://pnahratow.github.io/static/modprog/07_hip_head_detail.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Extruded the belly plate and arm ammo packs. Also defined the shoulder/glove transition.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Plate and glove details" src="https://pnahratow.github.io/static/modprog/08_plate_glove_detail.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create the leg ammo packs and face indentation using the extrude tool.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Visor and legammo details" src="https://pnahratow.github.io/static/modprog/09_shade_legpacks_detail.png"&gt;&lt;/p&gt;
&lt;h2 id="done"&gt;Done&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Finally removed edgeloops that don't add much to the form to reduce polycount.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Done backside" src="https://pnahratow.github.io/static/modprog/10_done_backside.png"&gt;
&lt;img alt="Done frontside" src="https://pnahratow.github.io/static/modprog/11_done_frontside.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Added a weapon (chainsaw-grenade-launcher) and a "muzzle flash"&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="With weapon" src="https://pnahratow.github.io/static/modprog/12_with_weapon.png"&gt;&lt;/p&gt;
&lt;h2 id="uv-mapping"&gt;UV Mapping&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;This is how the model was cut for uv mapping. The red edges mark uv seams.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="UV cuts and seams" src="https://pnahratow.github.io/static/modprog/13_cut_and_seam.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Here the resulting UV map. I aligned some of the seam vertices to make hiding them easier later. Unwrapping option was set to "conformal" most of the time.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="UV map" src="https://pnahratow.github.io/static/modprog/15_uv_map.png"&gt;
&lt;img alt="Testmap on model" src="https://pnahratow.github.io/static/modprog/14_test_uv.png"&gt;&lt;/p&gt;</content><category term="projects"></category><category term="gaming"></category></entry><entry><title>Creating Models For Quake 1</title><link href="https://pnahratow.github.io/creating-models-for-quake-1.html" rel="alternate"></link><published>2016-02-28T00:00:00+01:00</published><updated>2016-02-28T00:00:00+01:00</updated><author><name>Philipp Nahratow</name></author><id>tag:pnahratow.github.io,2016-02-28:/creating-models-for-quake-1.html</id><summary type="html">&lt;p&gt;&lt;em&gt;Update 2024: I fixed some of the broken and outdated links. Removed some steps which no longer work, Added some information which I felt was beneficial&lt;/em&gt;&lt;/p&gt;
&lt;h1 id="preface"&gt;Preface&lt;/h1&gt;
&lt;p&gt;This is kind of a tutorial/gathering of infomation about creating a model (specifically enemy model) for quake 1. I recently went through …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;Update 2024: I fixed some of the broken and outdated links. Removed some steps which no longer work, Added some information which I felt was beneficial&lt;/em&gt;&lt;/p&gt;
&lt;h1 id="preface"&gt;Preface&lt;/h1&gt;
&lt;p&gt;This is kind of a tutorial/gathering of infomation about creating a model (specifically enemy model) for quake 1. I recently went through the whole process and want to share some of the stuff I've learned.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Image of monster model" src="https://pnahratow.github.io/static/mdltut/mon_knut.png"&gt;&lt;/p&gt;
&lt;p&gt;I'm a hobbyist and learned most of this as I went along. Aside from the part about texture-painting (which I have done in before) this is more a collection of links than a tutorial.&lt;/p&gt;
&lt;h1 id="index"&gt;Index&lt;/h1&gt;
&lt;div class="toc"&gt;&lt;span class="toctitle"&gt;Table of Contents&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#preface"&gt;Preface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#index"&gt;Index&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#software"&gt;Software&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#creating-the-model"&gt;Creating The Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#creating-the-uv-map"&gt;Creating The UV Map&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#seams-stretching-and-shapes"&gt;Seams, Stretching and Shapes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#applying-the-image-texture"&gt;Applying The Image Texture&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#painting-the-texture"&gt;Painting The Texture&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#tablet"&gt;Tablet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#brushes"&gt;Brushes&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#paintbrush"&gt;Paintbrush&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#smudger"&gt;Smudger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#softie"&gt;Softie&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#workflow-and-tips"&gt;Workflow and Tips&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#basic-shading-progression"&gt;Basic Shading Progression&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#2d-3d-back-and-forth"&gt;2d-3d Back And Forth&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#double-resolution"&gt;Double Resolution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#blending-modes"&gt;Blending Modes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#use-more-colors"&gt;Use More Colors&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rigging"&gt;Rigging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#animation"&gt;Animation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#exporting-to-mdl"&gt;Exporting To MDL&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#the-quake-palette"&gt;The Quake Palette&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#palette-conversion-and-dithering"&gt;Palette conversion and Dithering&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#scale-location-and-rotation"&gt;Scale, Location and Rotation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#directory-structure"&gt;Directory Structure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#level-editor"&gt;Level Editor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#quakec"&gt;QuakeC&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#setup"&gt;Setup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#coding"&gt;Coding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h1 id="software"&gt;Software&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blender.org"&gt;Blender&lt;/a&gt; - for 3d modeling&lt;/li&gt;
&lt;li&gt;&lt;a href="https://bitbucket.org/khreathor/mdl-for-blender/wiki/Home"&gt;Quake MDL import/export plugin for Blender&lt;/a&gt; - for exporting to mdl format&lt;/li&gt;
&lt;li&gt;&lt;a href="http://krita.org"&gt;Krita&lt;/a&gt; - for digital painting&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.fteqcc.org/"&gt;Fteqcc&lt;/a&gt; - for compiling quakec&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.moddb.com/games/quake/downloads/quake-c-version-106"&gt;QuakeC v1.06 Base&lt;/a&gt; - as a codebase for quakec&lt;/li&gt;
&lt;li&gt;&lt;a href="http://slade.mancubus.net/"&gt;Slade3&lt;/a&gt; - for exploring quake1 pak files&lt;/li&gt;
&lt;li&gt;&lt;a href="http://kristianduske.com/trenchbroom/"&gt;Trenchbroom&lt;/a&gt; - for editing quake levels&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="creating-the-model"&gt;Creating The Model&lt;/h1&gt;
&lt;p&gt;I saw this video &lt;a href="https://www.youtube.com/watch?v=nm4E5QG9ZDM"&gt;Protoss Leg Modeling Method&lt;/a&gt; some time ago. Although it is not much I really liked it because it shows a flowchart way of modeling shapes that have a cylindrical nature. It's something I understood and was confident that I could replicate. It is how I did the legs of the model.&lt;/p&gt;
&lt;p&gt;Doing this in Blender seemed cumbersome at first because the box selection tool uses a keyboard shortcut &lt;kbd&gt;B&lt;/kbd&gt; instead of just beeing the right mouse default function. But I then discovered that &lt;kbd&gt;A&lt;/kbd&gt; is De/select-All and this becomes super fast by alternating &lt;kbd&gt;A&lt;/kbd&gt;,&lt;kbd&gt;B&lt;/kbd&gt;.&lt;/p&gt;
&lt;p&gt;There is alot to learn about blender and I haven't really scratched the surface but &lt;a href="http://blender.stackexchange.com/"&gt;blender.stackexchange.com&lt;/a&gt; is the ultimate resource of awesome and &lt;kbd&gt;SPACE&lt;/kbd&gt; opens a textfield that lets you search for anything in blender.&lt;/p&gt;
&lt;p&gt;Aside from that I would urge you to visit the &lt;a href="https://www.youtube.com/user/DarrinLile"&gt;Youtube Channel of Darrin Lile&lt;/a&gt; because thats where I learned what I wanted in an enjoyable and easy to grasp manner.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Plain model" src="https://pnahratow.github.io/static/mdltut/plain_model.png"&gt;&lt;/p&gt;
&lt;h1 id="creating-the-uv-map"&gt;Creating The UV Map&lt;/h1&gt;
&lt;p&gt;In order to paint the texture the model needs to be unwrapped. Which means the models needs information about how a 2d image would be applied to the 3d polygons to be its texture. A result of this looks something like this.&lt;/p&gt;
&lt;p&gt;&lt;img alt="UV Maps example" src="https://pnahratow.github.io/static/mdltut/uv_map.png"&gt;&lt;/p&gt;
&lt;p&gt;Again by Darrin Lile: &lt;a href="https://youtube.com/playlist?list=PLyelx0TsmSpdQwcx1OloZuW48bOUJQ02s&amp;amp;si=z-NWbs_v2odMHITa"&gt;Blender Character UV Mapping&lt;/a&gt; you can pretty much follow this tutorial exactly.&lt;/p&gt;
&lt;h2 id="seams-stretching-and-shapes"&gt;Seams, Stretching and Shapes&lt;/h2&gt;
&lt;p&gt;The tutorial talks a bit about stretching and seam placement. One thing I would add to that would be to keep in mind that you want to paint the texture later. When you use blenders 3d painting tools this is less of a problem. But in an imageeditor some seams are very hard to fix. Try to make seams straight lines where possible because that is easily to hide by copying/mirroring. Also try to maintain recognizable shapes. When painting one tends to stick to how he/she would do it in a drawing. Stretches and forms that only look good on the model but are weird on the texturemap are hard to paint. Usually the painted texturemap should look cool by itself.&lt;/p&gt;
&lt;h2 id="applying-the-image-texture"&gt;Applying The Image Texture&lt;/h2&gt;
&lt;p&gt;Blender has different renderers and applying texture has something to do with materials which are defined differently for these renderers. I didn't care to learn much about this. Just know that the MDL exporter expects the texture to be at a specific place when exporting. To achieve this try to drag'n'drop your image file from you file explorer onto the object in blender. I don't know what magic happens there but it just worked and I didn't want to think about it more than this.&lt;/p&gt;
&lt;h1 id="painting-the-texture"&gt;Painting The Texture&lt;/h1&gt;
&lt;p&gt;This step essentially comes down to plain digital painting where you handpaint everything starting from a blank screen. There is no single tutorial for this because the topic is vast and people spend lifetimes on it. If you've never done anything in this area your texture will probably come out sub par at first but I do want to encourage you. I personally was very invested into pursuing 2d art at one point in my life but stopped because I realized I wasn't quite willing to put in the necessary work to get gud.&lt;/p&gt;
&lt;p&gt;However painting textures for a 3d model is less hard. Proportions and perspective is taken care of by the 3d model and you won't have to worry about that. Gamemodels are usually moving so you can get away with textures that don't ooze perfection in still. Also, especially old tech like quake can be very forgiving because of the low resolutions. If you for example have trouble painting ears that won't be more than a couple of pixels in the end so don't sweat it. What I'm saying is that it's possible to make at least decent 2d gameart without being a dedicated 2d artist.&lt;/p&gt;
&lt;h2 id="tablet"&gt;Tablet&lt;/h2&gt;
&lt;p&gt;A graphic tablet is a necessity in my opinion. Maybe not if you primarily do very technical stuff like machines, mechs, weapons or if you are a superb pixel artists but when it comes to organic forms I wouldn't want to use a mouse.&lt;/p&gt;
&lt;p&gt;Wacom makes great products. I have a Graphire4 which is old but does the job. I wish I had more pressure levels and more DPI but it's not a big problem. Basically if you're starting out get any wacom tablet that suits your price doesn't matter which. If you wan't to have something better get an Intuos Pro or Cintiq.&lt;/p&gt;
&lt;h2 id="brushes"&gt;Brushes&lt;/h2&gt;
&lt;p&gt;Photoshop is great but expensive. Gimp is great but also not. I recently tried Krita which I like. Doesn't matter which software - I always try to assemble this basic set of tools.&lt;/p&gt;
&lt;h3 id="paintbrush"&gt;Paintbrush&lt;/h3&gt;
&lt;p&gt;A tool to lay down paint. I use only one because I'm not very experienced and don't know how to handle the many presets there are. I know how to use a real pencil and thats why I fiddle with the brush settings until I can comfortably create this gradienty kind of thing in one stroke.&lt;/p&gt;
&lt;p&gt;&lt;img alt="A painted gradient" src="https://pnahratow.github.io/static/mdltut/brush_gradient.png"&gt;&lt;/p&gt;
&lt;p&gt;Here are a couple of tips to get this&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The brushtip is 100% hard.&lt;/li&gt;
&lt;li&gt;Play with the density/spacing. Try 100%.&lt;/li&gt;
&lt;li&gt;Pressuresensitivity is on for size and opacity&lt;/li&gt;
&lt;li&gt;If you're not super precise with the pressure. Try limiting the size range maybe only 100%-80%.&lt;/li&gt;
&lt;li&gt;If you're not super precise with the pressure. Play with the pressure curve for opacity. Make it so that 100% opacity only comes when you press real hard.&lt;/li&gt;
&lt;li&gt;If opacity builds up during one stroke when you pass a section twice. Try to deactivate that. Search for "build up" or "wash" mode.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="smudger"&gt;Smudger&lt;/h3&gt;
&lt;p&gt;Literally satan. Having hard edges is a thing that makes stuff look crisp. It's why I use a hard brush to paint. Blurry brushstrokes is one of the most common things that makes beginner artwork look bad. Still I use this tool. Most of the time when evening out too harsh highlights like this.&lt;/p&gt;
&lt;p&gt;&lt;img alt="A smudged highlight" src="https://pnahratow.github.io/static/mdltut/smudge_hl.png"&gt;&lt;/p&gt;
&lt;p&gt;This brush is 2-4px wide and at 20-40% strength.&lt;/p&gt;
&lt;h3 id="softie"&gt;Softie&lt;/h3&gt;
&lt;p&gt;A big round brush with soft edges and very low opacity. I use this to create soft gradients or to apply color lighly without disrupting anything. Usually in a situation where I have a selection and then use the side of the brush like this.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Application for soft brushes" src="https://pnahratow.github.io/static/mdltut/softbrush_appl.png"&gt;&lt;/p&gt;
&lt;h2 id="workflow-and-tips"&gt;Workflow and Tips&lt;/h2&gt;
&lt;p&gt;I attack the empty texture with this basic arsenal until I'm happy with what I see. At this point I feel like a crazy person running in circles hoping for something good to happen. All the brushstrokes are bad. Colors look off or boring but I know it gets better when I invest more time so I keep at it. I can't say much about this but other people can. Check out youtube for people who post about general digital art like &lt;a href="https://www.youtube.com/user/Sycra"&gt;Sycra&lt;/a&gt;. I'm sure you can find many more.&lt;/p&gt;
&lt;h3 id="basic-shading-progression"&gt;Basic Shading Progression&lt;/h3&gt;
&lt;p&gt;I made a &lt;a href="https://pnahratow.github.io/chainforcer-texture-paint-workflow.html"&gt;timelapse video of my texturing workflow&lt;/a&gt; for another model.&lt;/p&gt;
&lt;h3 id="2d-3d-back-and-forth"&gt;2d-3d Back And Forth&lt;/h3&gt;
&lt;p&gt;I paint exclusively in the 2d software but I need to constantly check the 3d model if everything is right. To do this comfortably I have blender on the 2nd monitor (or in the background). I use "3D View Full" as the screenlayout to get rid of the grid and stuff. In the view options &lt;kbd&gt;N&lt;/kbd&gt; I activate Display -&amp;gt; Shadeless because I don't want blenders ugly shading but fullbright instead. I split the window and also open a UV-Image-Editor view and activiate the options side-bar &lt;kbd&gt;N&lt;/kbd&gt;. Under image there is the texture file and you can press the refresh button next to it to reload the texture. Blender can read PSD files and krita and gimp can also work with them. PSD files preserve layers and thats how this all becomes comfortable. Paint a little, save, press refresh in blender, repeat.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Blender Reload Texture" src="https://pnahratow.github.io/static/mdltut/reload_tex.png"&gt;&lt;/p&gt;
&lt;h3 id="double-resolution"&gt;Double Resolution&lt;/h3&gt;
&lt;p&gt;My brushstrokes are wonky and I don't know how to do close-up pixel pushing. What I do to help with that is paint the texture in twice the resolution. If the target texture is 256x256px I paint in 512x512px. The downscaling in the end smooths out some of the irregularities. Lazily done gradients become smooth and some mistakes disappear. However the whole image becomes blurry and looses contrast too. To help with that there is a filter called "Unsharp Mask" (look under sharpen or enhance). Use with low values. The image below shows how to get some of the crispness back with this filter.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Unsharp Mask filter result" src="https://pnahratow.github.io/static/mdltut/unsharp_mask.png"&gt;&lt;/p&gt;
&lt;h3 id="blending-modes"&gt;Blending Modes&lt;/h3&gt;
&lt;p&gt;Learn about blending modes regarding brushes and layers. There are cool light effects like rimlights, neon glow, fire and subsurface scattering and all those flashy things. They look great on textures. Blending modes help with this. You should become familiar with multiply, screen/lighten, dodge, burn and overlay. Check out this video: &lt;a href="https://www.youtube.com/watch?v=AybFWViT-3Q"&gt;Painting with Blending-modes
&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="use-more-colors"&gt;Use More Colors&lt;/h3&gt;
&lt;p&gt;A quick thing on colors. If you experience the problem that your skintones look dull or off. Check out this video: &lt;a href="https://www.youtube.com/watch?v=PPdkEEYo3F0"&gt;How to Paint Realistic Skin Tones&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id="rigging"&gt;Rigging&lt;/h1&gt;
&lt;p&gt;Rigging means preparing the model in a way that makes it easy to pose the model. Usually by applying some kind of virtual bone structure where you can move hands or feet in 3d space and the other joints move in some realistic manner too which saves you time.&lt;/p&gt;
&lt;p&gt;The keyword here is inverse kinematics and I can only point you to videos by Darrin Lile again. &lt;a href="https://www.youtube.com/watch?v=Q2MGttB1E7U&amp;amp;list=PLyelx0TsmSpf-8xZfjZveokSsIwj0F3lo&amp;amp;index=22"&gt;Blender Character Rigging&lt;/a&gt; and following explain the manual process defining bones and their properties and it's the method I used.&lt;/p&gt;
&lt;p&gt;A way easier approach for is using Blenders riggify addon. See &lt;a href="https://www.youtube.com/watch?v=PKPo0-leJmU"&gt;Rigify Made Easy&lt;/a&gt;. Which makes it easy because there a predefined skeletons you can use by just aligning the joints with your model and pressing "Generate Rig".&lt;/p&gt;
&lt;p&gt;&lt;img alt="Bone rig" src="https://pnahratow.github.io/static/mdltut/bone_rig.png"&gt;&lt;/p&gt;
&lt;h1 id="animation"&gt;Animation&lt;/h1&gt;
&lt;p&gt;Now this again is a topic that dabbles in the domain of art. Animation is hard and demands a feel for poses, motion and movement. Even if you are good at this things might not look they way you intend. This is especially true for walk and run animations because it's a thing we as humans see a lot and can see every minute problem in. See &lt;a href="https://en.wikipedia.org/wiki/Uncanny_valley"&gt;uncanny valley&lt;/a&gt; for more information about this.&lt;/p&gt;
&lt;p&gt;I used keyframe animation which is a technique where you define the distinct poses that appear in the animation you want to make and the software (blender) does the job of interpolating the in-between states that appear.&lt;/p&gt;
&lt;p&gt;Some tips&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Identify &lt;strong&gt;extreme poses&lt;/strong&gt; in your animation, pose them and set full character keyframes at those points. Then define the inbetween stages afterwards. Just going from left to right sometimes causes headaches and this bisecting approach usually works better.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Make animations loopable&lt;/strong&gt;. There are two ideas here. Either you loop into the first frame of your animation so that the animations itself loop well. You can do this like this: When you are almost done with one animation copy the pose of the first frame of the current animation and paste it somewhere after your last keyframe. Then go back and find a good "almost there" pose and copy this as your actual last frame of the animation. This way you are blending into the loop. Another approach is to &lt;strong&gt;blend into your characters primary animation&lt;/strong&gt; which usually is the run cycle. Do the same as before just use the first frame of your run cycle as the base.&lt;/li&gt;
&lt;li&gt;Better yet. Get to know the helpful quality of life features blender has around animation. If you are unfamiliar with this just know that there are serious shortcuts to be found everywhere. See &lt;a href="https://www.youtube.com/watch?v=GAIZkIfXXjQ"&gt;Character animation for impatient people - Blender Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I made an in-game &lt;a href="https://youtu.be/sDa8cVHDhP4"&gt;youtube video&lt;/a&gt; of my final model. At around 00:46 you can see all the animations that the model uses.&lt;/p&gt;
&lt;p&gt;This is a part I will have to learn alot about too. For the technicalities I can again refer you to &lt;a href="https://www.youtube.com/playlist?list=PLyelx0TsmSpfoqyS2sBZvsuIL5av5DkJu"&gt;Blender Character Animation&lt;/a&gt; other than that you'll have to trial-and-error yourself through this. Which is what I did too.&lt;/p&gt;
&lt;p&gt;Some things to note&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Quake animates at 10fps, set blender to this playback speed to see how it shows up in quake&lt;/li&gt;
&lt;li&gt;The different animations (like jump, die, shoot) will be one after the other in the timeline. If you have auto-keyframing (red record button) activated you can press &lt;kbd&gt;A&lt;/kbd&gt; to select every bone and then &lt;kbd&gt;ALT&lt;/kbd&gt;+&lt;kbd&gt;R&lt;/kbd&gt; and &lt;kbd&gt;ALT&lt;/kbd&gt;+&lt;kbd&gt;G&lt;/kbd&gt; to reset the pose while also thouching every bone whichs creates a keyframe for each bone. This eliminates weird interpolation issues and is something I did for the first frame of each animation. Another more explicit way to do this is by using the menu &lt;em&gt;Pose -&amp;gt; Animation -&amp;gt; Insert Keyframe -&amp;gt; Whole Character&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Use existing quake models for reference about how many frames an animation should take and how the poses are spaced. I used the dog/rottweiler for reference.&lt;/li&gt;
&lt;li&gt;The whole animation part goes hand in hand with the quakec and your idea of the behaviour of the model. You probably should do the coding and animating simultaneously if you are working on a brand new model.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="exporting-to-mdl"&gt;Exporting To MDL&lt;/h1&gt;
&lt;p&gt;This step is pretty easy because the MDL exporter does everthing for you. Note that animation is exported from frame 1 to the frame you have currently selected.&lt;/p&gt;
&lt;p&gt;Check this video &lt;a href="https://www.youtube.com/watch?v=nZC-G9Tz6OM"&gt;MDL for Blender 2.8 - Common Problems, Quirks and Solutions
&lt;/a&gt; to get some more detailed information.&lt;/p&gt;
&lt;h2 id="the-quake-palette"&gt;The Quake Palette&lt;/h2&gt;
&lt;p&gt;&lt;img alt="Quake color palette" src="https://pnahratow.github.io/static/mdltut/quake_pal.png"&gt;&lt;/p&gt;
&lt;p&gt;https://quakewiki.org/wiki/Quake_palette&lt;/p&gt;
&lt;p&gt;Quake 1 textures have only 256 colors. Luckily this is something the mdl exporter does take care of too. It finds the closest color match for each pixel of your texture and converts the image this way. However there is one thing to be wary of. The last 32 color in this palette are fullbright colors. In-game quake does manipulate your texture color according to the current light value. But not the last 32 colors. These colors are there for various lights or fire that stay fully lit no matter where they are. An inconvenient sideeffect of this is that the mdl exporter might interpret some of your texture's colors as these fullbright colors and you'll get some weirdly lit pixels in your texture.&lt;/p&gt;
&lt;p&gt;This is how the texture looks after the palette conversion. You can see some artifacts in the gradients which makes it look like its 1996.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Texture after conversion" src="https://pnahratow.github.io/static/mdltut/after_quakepal.png"&gt;&lt;/p&gt;
&lt;h3 id="palette-conversion-and-dithering"&gt;Palette conversion and Dithering&lt;/h3&gt;
&lt;p&gt;As you can see there are some nasty jumps in the gradient there. To avoid this and also the issue with the fullbright colors you can take care of the color conversion manually. For this you can use Krita using the &lt;em&gt;Map -&amp;gt; Palettelize&lt;/em&gt; filter. There you have a bunch of options to make it look good. You can also use a dedicated tool like &lt;a href="https://captain4lk.itch.io/slk-img2pixel"&gt;SLK-img2pixel&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Palette conversion comparison" src="https://pnahratow.github.io/static/mdltut/dither_comp.png"&gt;&lt;/p&gt;
&lt;p&gt;In the example above you can see the result of the exporter on the left and on the right I used SLK-img2pixel. You can see the it all looks much nicer. If you zoom in you can also see the familiar dithering patterns from ancient times.&lt;/p&gt;
&lt;p&gt;To avoid the fullbright issue you just use a reduced palette for the conversion.&lt;/p&gt;
&lt;h2 id="scale-location-and-rotation"&gt;Scale, Location and Rotation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The mdl exporter translates blender units to quake units 1:1. This means that quake models are giant behemoths in blender. Import an original quake model into your scene and scale your model so it looks good in comparison. Also you should keep the hit/hurt boxes of the enemies in mind. I don't know the specifics of it yet but I think it's the same box you see in a leveleditor when placing monsters. They are usually power of 2 boxes like 32x32 and I think you can also influence this in quakec. With my model I just sticked with the original dog/rottweiler monster and scaled my model so it fits that box.&lt;/li&gt;
&lt;li&gt;The floor in quake is at -24 units. Create a plane at -24 and move your model so it nicely stands on this plane.&lt;/li&gt;
&lt;li&gt;If you import an original mdl into blender you'll see it facing in an other direction by 90°. You should do this to your model too but maybe only after animating if you want to use the X-Mirror tool while animating.&lt;/li&gt;
&lt;li&gt;Lastly. Scale, location and rotation shouldn't be properties of the object. The object should have a scale of 1, rotation of 0° and location of 0 on all axis. If thats not the case press &lt;kbd&gt;CTRL&lt;/kbd&gt;+&lt;kbd&gt;A&lt;/kbd&gt;-&amp;gt;Location and &lt;kbd&gt;CTRL&lt;/kbd&gt;+&lt;kbd&gt;A&lt;/kbd&gt;-&amp;gt;Rotation&amp;amp;Scale to transfer these values to the mesh.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="directory-structure"&gt;Directory Structure&lt;/h2&gt;
&lt;p&gt;Since the new model will have model, sound and code it essentially becomes a quake mod. Mods get their own directory in your quake installation and you will have to start quake with &lt;code&gt;-game &amp;lt;yourdirectory&amp;gt;&lt;/code&gt; commandline arguments. Check out other quake mods for directory and naming conventions. The mdl file usually goes in the progs directory.&lt;/p&gt;
&lt;h2 id="level-editor"&gt;Level Editor&lt;/h2&gt;
&lt;p&gt;I use trenchbroom as the quake level editor. To use a new model in there you will need an entity definiton. Trenchbroom reads .fgd and .def files and comes with a standard quake entity definition .fgd file in its resource directory. Copy that and add your own entity defintion to this. It will look something like this.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@PointClass base(Monster) size(-32 -32 -24, 32 32 40) model(":progs/mon_knut.mdl") = mon_knut : "Nasty Manbearpig" []
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Size defines the bounding box. Model defines the model that is shown in the editor. The string after the = defines the entity spawn function that will be called when quake loads the map.&lt;/p&gt;
&lt;p&gt;To add your .fgd file in trenchbroom got to the inspector on the right. At the bottom of the entity tab you can use external .fgd files. At the bottom of the map tab you can activate mods directories to be read.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Trenchbroom screenshot" src="https://pnahratow.github.io/static/mdltut/trenchbroom.png"&gt;&lt;/p&gt;
&lt;h1 id="quakec"&gt;QuakeC&lt;/h1&gt;
&lt;p&gt;Having experience in programming will help but if you made it here you probably don't care and are willing to learn whatever is necessary. Which is good because programming is fun.&lt;/p&gt;
&lt;h2 id="setup"&gt;Setup&lt;/h2&gt;
&lt;p&gt;You will need the code base and also the compiler (fteqcc). Create a directory in you mod directory and name it qc or whatever. Extract the code base there. For simplicity's sake also copy the compiler there. (I've put the compiler binary in my &lt;code&gt;PATH&lt;/code&gt; environment variable and call it using &lt;code&gt;qcc&lt;/code&gt; anywhere). When you run the compiler it looks for a file named &lt;code&gt;progs.src&lt;/code&gt; in the current directory. It then compiles every quakec file listed there in order and creates the resultfile &lt;code&gt;PROGS.DAT&lt;/code&gt; in the parent directory (which should be the root directory of your mod). When you start quake with the &lt;code&gt;-game &amp;lt;yourdirectory&amp;gt;&lt;/code&gt; parameter quake will read your &lt;code&gt;PROGS.DAT&lt;/code&gt; instead of the vanilla quake one and all gameplay behaves the way you defined in the quakec files. This is where &lt;a href="http://www.insideqc.com/qctut/"&gt;the fun starts&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://pages.cs.wisc.edu/~jeremyp/quake/quakec/quakec.pdf"&gt;QuakeC Reference Manual&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="coding"&gt;Coding&lt;/h2&gt;
&lt;p&gt;Read this &lt;a href="https://tomeofpreach.wordpress.com/qexpo-tutorial/"&gt;Tutorial by Preach&lt;/a&gt; (specifically Day6 and 7). If you use GMAX instead of blender the whole tutorial would be the one to read in the first place. However he explains how the animation data from the model is linked to the behaviour in quakec.&lt;/p&gt;
&lt;p&gt;Blender animation frame 0 gets discarded on mdl export and your animations should start at 1. Quake counts starting from 0 but that shouldn't concern you since you should use the &lt;code&gt;$frame&lt;/code&gt; directive mentioned in the preach's tutorial. You only need to know how many frames each of your animations last. Give each of your animation frames a name with this &lt;code&gt;$frame&lt;/code&gt; directive and then refer to these in the think functions.&lt;/p&gt;
&lt;p&gt;Of course defining animations isn't the end of it. For the whole behaviour part I'd suggest you to scour about in the files of the quakec base. The definitions for each original monster is in there ranging from melee attacks, to projectiles, grenades, movement and more. Use what you can find.&lt;/p&gt;
&lt;p&gt;I hope you did get good infomation out of this tutorial and I wish you good look realizing your project.&lt;/p&gt;
&lt;p&gt;&lt;img alt="In-game screenshot" src="https://pnahratow.github.io/static/mdltut/ingame.png"&gt;&lt;/p&gt;</content><category term="projects"></category><category term="gaming"></category></entry></feed>